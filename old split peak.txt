      }
    # If we are currently in state split_check, we are still searching for that low point...
    # Not correct. Misses the split when jump to split distance gets up to next peak
    # in sequence, so we end up here without splitting. This downward move can
    # actually be the falling phase on the *next* peak.
    } else if (current_state == st_split_check){
      # Moving downward within the pulse, update min if appropriate
      if (delta_conc <= 0) {
        if (next_conc < current_dip_conc){
          current_dip_loc <- next_loc
          current_dip_conc <- rescaled_conc[current_dip_loc]
        }
      # delta_conc > 0, so we're  moving back up. Check for big enough move from min  
      } else if ((current_conc - current_dip_conc) > peak_split_depth) {
        current_state <- st_splitting
      }